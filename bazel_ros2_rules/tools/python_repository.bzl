"""
Finds local system Python headers and libraries using python-config and
makes them available to be used as a C/C++ dependency.

This implementation is inspired by the one in Drake, but uses
sysconfig instead.

Arguments:
    name: A unique name for this rule.
    python_interpreter: Name or path to the python interpreter. (optional)
"""

load("@bazel_ros2_rules//tools:execute.bzl", "execute_or_fail")

def python_info(repo_ctx, python_command):

    interpreter_path = execute_or_fail(repo_ctx,
        [python_command, "-c", "import sys; print(sys.executable)"]).stdout

    version = execute_or_fail(repo_ctx,
        [python_command, "-c", "import sysconfig; print(sysconfig.get_python_version())"]).stdout

    include = execute_or_fail(repo_ctx,
        [python_command, "-c", "import sysconfig; print(sysconfig.get_path('include'))"]).stdout

    platinclude = execute_or_fail(repo_ctx,
        [python_command, "-c", "import sysconfig; print(sysconfig.get_path('platinclude'))"]).stdout

    extension_suffix = execute_or_fail(repo_ctx,
        [python_command, "-c", "import sysconfig; print(sysconfig.get_config_var('EXT_SUFFIX'))"]).stdout
    if "None" == extension_suffix:
        fail("Failed to get python extension suffix")

    return struct(
        interpreter_path = interpreter_path.strip(),
        version = version.strip(),
        includes = [include.strip(), platinclude.strip()],
        extension_suffix = extension_suffix.strip(),
    )

def _impl(repo_ctx):
    py_info = python_info(repo_ctx, repo_ctx.attr.python_command)

    skylark_content = """
# DO NOT EDIT: generated by python_repository()
# WARNING: Avoid using this macro in any repository rules which require
# `load()` at the WORKSPACE level. Instead, load these constants through
# `BUILD.bazel` or `package.BUILD.bazel` files.

PYTHON_INTERPRETER_PATH = "{interpreter_path}"
PYTHON_EXTENSION_SUFFIX = "{extension_suffix}"
PYTHON_VERSION = "{version}"
PYTHON_INCLUDES = {includes}
""".format(
        interpreter_path = py_info.interpreter_path,
        extension_suffix = py_info.extension_suffix,
        version = py_info.version,
        includes = py_info.includes
    )
    repo_ctx.file(
        "pyinfo.bzl",
        content = skylark_content,
        executable = False,
    )

    build_content = """# DO NOT EDIT: generated by python_repository()

licenses(["notice"])  # Python-2.0

load("@python//:pyinfo.bzl", "PYTHON_INCLUDES")

cc_library(
    name = "python_headers",
    includes = PYTHON_INCLUDES,
    visibility = ["//visibility:private"],
)

cc_library(
    name = "python_cc",
    includes = PYTHON_INCLUDES,
    linkopts = [],
    visibility = ["//visibility:public"],
    deps = [":python_headers"],
)
"""

    repo_ctx.file(
        "BUILD.bazel",
        content = build_content,
        executable = False,
    )

python_repository = repository_rule(
    _impl,
    attrs = {
        "python_command": attr.string(default="python3"),
    },
    local = True,
    configure = True,
)


# python_repository() creates a bazel repository with generated starlark with info about
# the python installation
# cpython_extension() is a macro that creates a cpython extension, using info from python_repository()
# cpython_extension has to load stuff from generated repository, so it can't live in this file.
